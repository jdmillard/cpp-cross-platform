
#if CMAKE_LINUX
#include <uuid.h>
#endif

#if CMAKE_MACOS
// TODO
#endif

#if CMAKE_WINDOWS
//#include <windows.h> // this seems to just work, but is not required (but does it work without VS installed?)
#include <objbase.h> // this seems to just work thanks to cmake adding the windows sytem include directories (but does it work without VS installed?)... move to other header
#endif


#include "example.h"

// TODO: test out build on clean windows installation to see if SDK is required

// example typedef:
// typedef existing new;

int main(int argc, char **argv)
{

    #if CMAKE_LINUX
    std::cout << "running on linux" << std::endl;

    uuid_t allocated; // uuid type

    int aaa = 6;
    uuid_generate(allocated);
    aaa = uuid_is_null(allocated);
    std::cout << aaa << std::endl;

    std::cout << std::endl << std::endl;
    #endif

    #if CMAKE_MACOS
    std::cout << "running on mac" << std::endl;
    #endif

    #if CMAKE_WINDOWS
    std::cout << "running on windows" << std::endl;

    GUID allocated;
    CoCreateGuid(&allocated);

    #endif

    // TODO: test these flags on macOS

    // PLAN
    // we have a paved path for using naitive system libraries for uuids
    // look into what types can be generated by each lib
    // id class needs these features:
        // evaluate if the same as other id
        // swallow/be swallowed
        // contain list of ids that have been swallowed

    // IDs FOR TRACKS:
    // various unsigned chars come through subscription (the first one is the track id and subsequent ones are adopted ids)
    // throw all of these into a new id class
    // compare local id classes to see if already equal (return bool)
    // after additional state checks, etc, once confirmed the same, a way to merge

    // if timestamps are to be extracted from the UUID, use this post:
    // https://stackoverflow.com/a/15179513
    // and create a test that makes sure the time extraction method works (test will have a hardcoded UUID value)

    // new UUID experiments



    // make an id class (think of good name for this)
    // there will be a uuid_t member, everything revolves around this member
    // operator. the uuid_t member will point to the type based on the system
    // the comparison functions will be compiler-defined based on the library
    // system-level library differences will be abstracted away
    // I'm not sure what to do about pointers

    // PLAN: use unix/windows/apple libraries for uuid comparison
    // which means the high-level class needs pounddefine to
    // force usage of naitive lib functions

    // documentation as well as other links for uuid library:
    //https://linux.die.net/man/3/uuid_generate

    // if the default uuid libraries can be managed from the custom module so that
    // only the #include is needed, we do #DEFINE compiler logic for building
    // a uuid class and/or custom type struct which will abstract away the
    // platform dependent API

    // BELOW IS ARTIFACTS OF INHERITED STRUCTURE

    // instantiate the wrapper class
    WrapperClass shell_object;


    std::cout << "terminating main" << std::endl;
} // end of main
